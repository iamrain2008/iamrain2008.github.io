[{"title":"二叉树算法从入门到精通","url":"/2020/Learn-Binary-Tree/","content":"\n\n# 3种遍历顺序\n\n二叉树遍历算法，根据根节点相对于左节点、右节点的不同访问顺序，分为`前序遍历(Pre-Order Traversal)`、`中序遍历(In-Order Traversal)`、`后序遍历(Post-Order Traversal)`。\n\n* 前序遍历：根节点第一个访问：根-左-右；\n* 中序遍历：根节点第二个访问：左-根-右；\n* 后序遍历：根节点最后访问：左-右-根。\n\n示例，假设有这样一个树：\n\n```\n      1\n     / \\\n    /   \\\n   2     3\n  / \\   / \\\n /   \\ /   \\\n4    5 6    7\n```\n\n* 前序遍历：1-2-4-5-3-6-7\n* 中序遍历：4-2-5-1-6-3-7\n* 后序遍历：4-5-2-6-7-3-1\n\n用递归实现的3种遍历是这样的：\n\n```\n/**\n * 这是我们的TreeNode的定义，后面所有例子用的TreeNode都是这样。\n */\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n    }\n}\n\n/**\n * 前序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    if (root.val is target) {\n        do something\n    }\n    treeTraversal(root.left);\n    treeTraversal(root.right);\n}\n\n/**\n * 中序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    treeTraversal(root.left);\n    if (root.val is target) {\n        do something\n    }\n    treeTraversal(root.right);\n}\n\n/**\n * 后序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    treeTraversal(root.left);\n    treeTraversal(root.right);\n    if (root.val is target) {\n        do something\n    }\n}\n```\n\n\n# 2种遍历策略\n\n树的遍历分为深度优先遍历和广度优先遍历。\n\n## 深度优先遍历\n\n深度优先(Depth First Search, DFS)的意思就是，先一条道走到黑，走到不能再走了，再回过头了遍历其他。\n下面用一个最简单的例子来说明不同的深度优先遍历。\n\n> [LeetCode 104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n深度优先遍历大致分为递归实现和非递归实现，递归实现又分为分治法实现和遍历法实现。\n\n### 用递归实现\n\n#### 分治法\n\n最常见，最好理解的方法，就是分治法。左右叶子节点返回它们自身的深度，取大的那个深度，+1再返回。\n\n```\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    int left = maxDepth(root.left);\n    int right = maxDepth(root.right);\n    return Math.max(left, right) + 1;\n}\n```\n\n#### 遍历法\n\n遍历法与分治法的本质区别是，分治法有个回归的过程，而遍历法没有。\n\n```\nint maxDepth;\n\npublic int maxDepth(TreeNode root) {\n    maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n    // 当前的深度为1，开始遍历\n    calculateTreeDepth(root, 1);\n    // 返回最终结果\n    return maxDepth;\n}\n\npublic void calculateTreeDepth(TreeNode treeNode, int currentDepth) {\n    if (treeNode == null) {\n        // 如果当前节点是null就什么都不做\n        return;\n    }\n    // 如果当前节点的深度大于已记录的最大深度，更新最大深度\n    if (currentDepth > maxDepth) {\n        maxDepth = currentDepth;\n    }\n    // 遍历左右子树，进入左右子树时的深度是当前深度+1，如果子树是null则不会更新maxDepth\n    calculateTreeDepth(treeNode.left, currentDepth + 1);\n    calculateTreeDepth(treeNode.right, currentDepth + 1);\n}\n```\n\n### 用非递归实现\n\n非递归（即迭代法）实现需要借助`栈`这个数据结构，实现方法比递归的麻烦一些，但很重要，一定要理解它的实现原理。\n还是以上面的计算树的最大深度为例子（其实更好的做法是广度优先遍历，这里只是为了展示非递归的实现）。\n\n\n```\npublic int maxDepthDfsNonRecursion(TreeNode root) {\n    int maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n\n    // Pair: key - TreeNode, value - int, current depth\n    Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\n    // Push root node to stack\n    stack.push(new Pair<>(root, 1));\n\n    while (!stack.isEmpty()) {\n        Pair<TreeNode, Integer> pair = stack.pop();\n        TreeNode node = pair.getKey();\n        int currentDepth = pair.getValue();\n\n        // Leaf, save the max depth\n        if (node.left == null && node.right == null && currentDepth > maxDepth) {\n            maxDepth = currentDepth;\n        }\n\n        if (node.right != null) {\n            stack.push(new Pair<>(node.right, currentDepth + 1));\n        }\n        if (node.left != null) {\n            stack.push(new Pair<>(node.left, currentDepth + 1));\n        }\n    }\n    return maxDepth;\n}\n```\n\n## 广度优先遍历\n\n广度优先(Breadth First Search, BFS)的意思就是，优先遍历当前节点的所有子节点，不管子节点还有没有孙子节点。再一层一层向下遍历。\n\n通常需要借助`队列`来完成遍历，思路是：记录当前层的数量，开始遍历，将叶子节点放入队列，当遍历的数量等于当前层数量时，说明当前层已经遍历完了；检查队列是否为空，不为空说明还有下层，继续重复刚才的操作；知道全部遍历完成。\n\n```\npublic int maxDepthBfs(TreeNode root) {\n    int maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n    // 建立队列辅助计算，并添加根元素\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    // 队列不空就开始遍历\n    while (!queue.isEmpty()) {\n        // 记录当前层一共有多少个元素\n        int currentLevelSize = queue.size();\n        // 记录已经查看了多少个元素\n        int visitedSize = 0;\n        // 开始遍历当前层\n        while (visitedSize < currentLevelSize) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                if (node.left != null) {\n                    // 有左叶子节点，则加入队列\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    // 有右叶子节点，则加入队列\n                    queue.offer(node.right);\n                }\n            }\n            // 处理当前node的值，本例中无需处理\n            // 记录我们看过一个元素了，当当前层所有元素都看过之后，会退出当前while循环\n            visitedSize++;\n        }\n        // 遍历完一层的时候，最大深度+1，如果下层还有元素，则会继续遍历\n        maxDepth++;\n    }\n    // 所有节点遍历完成，返回结果\n    return maxDepth;\n}\n```\n\n# 特殊的二叉树\n\n## 二叉搜索树\n\n## 红黑树\n\n# 多叉树\n\n> 未完待续","tags":["algorithm","leetcode","binary tree"],"categories":["Algorithm"]},{"title":"二分查找法从入门到精通","url":"/2020/Learn-Binary-Search/","content":"\n# 二分法的本质\n\n\n二分法通常用于在有序的集合中查找目标。通过O(1)的操作，将规模为`n`的问题分解为`n/2`，最终时间复杂度是`log(n)`。通常要求做到`log(n)`的时间复杂度，基本上都是二分法。\n\n\n# 二分法的痛点\n\n\n* 死循环\n  * 二分法通过`循环条件`+`指针变化`来推进，如果这两个组合不正确，就会导致死循环。\n* 是否可以使用递归(Recursion)\n  * 使用递归时，代码会更加清晰，写法更简单。不能用递归时，写法会复杂很多。有时候需要注意问题规模，使用递归是否可能导致溢出。\n\n\n# 二分法的基本写法\n\n\n```\nprivate int binarySearch(int[] nums, int target) {\n\n    // 对数据合法性进行判断\n    int badResult = -1;     // 表示没有target或nums不合法的数字，例如-1\n    if (nums不合法) {\n        return badResult;\n    }\n\n    // 设定左右指针\n    int left = 0;\n    int right = nums.length - 1;\n\n    // 开始循环\n    while (循环条件) {\n        \n        // 设定mid，这里的小技巧是使用右减左除以2再加上左，避免溢出，更好的写法是相加后无符号右移一位\n        int mid = (right + left) >>> 1;\n        \n        // 判断mid是否是所求目标，是的话返回\n        if (nums[mid] == target) {\n            return mid;\n        }\n\n        // 不是的话，判断移动左还是右指针，将问题规模减小一半\n        if (target在左侧) {\n            移动右指针\n        } else {\n            移动左指针\n        }\n    \n    }\n\n    // 视上述循环条件和移动指针的方式，执行额外的最终判断\n    最终判断\n    // 如果最终没有满足条件的结果，返回失败\n    return badResult;\n}\n```\n\n总结一下就是通过循环，不停的移动左右指针将问题规模减半，直到解决问题。\n\n这里的难点是`循环条件`和`移动左右指针的方法`，这两者使用不同的组合会有不同的效果，使用错了会导致死循环。下面我介绍一些常见的循环条件和移动左右指针的方法的组合。\n\n\n# 二分法常见模板\n\n\n基本上所有的二分查找算法都可以用下面3种模板之一来解决。\n\n## 模板1\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length - 1\n循环条件 | left <= right\n左指针移动 | left = mid + 1\n右指针移动 | right = mid - 1\n最终判断 | 无\n\n这个模板在退出循环时，left与right会交错而过(即left - 1 == right)，此时所有可能项目都查找过了，所以不需要额外的操作。\n\n\n## 模板2\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length\n循环条件 | left < right\n左指针移动 | left = mid + 1\n右指针移动 | right = mid\n最终判断 | left是否是target？\n\n模板2的right初始值需要注意一下，是length，这是为了配合left < right这个循环条件。\n\n这个模板在退出循环的时候，一定有left == right，此时因为不满足循环条件，所以这个值还没有判断过，于是在退出循环之后，还需要判断一次left是否是target（判断right也行，因为退出循环时left必然等于right）。\n\n\n## 模板3\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length - 1\n循环条件 | left + 1 < right\n左指针移动 | left = mid\n右指针移动 | right = mid\n最终判断 | left是否是target？right是否是target？\n\n模板3在退出循环的时候，left + 1 == right，也就是查找到了最后2个项目，这两个项目没有在循环中判断过，所以最终判断时需要分别看一下left和right是否是target\n\n\n# 模板的选择\n\n上面介绍了3种模板，他们的核心区别是\n\n<div style=\"width: 80px\">项目</div> | <div style=\"width: 33%\">模板1</div> | <div style=\"width: 33%\">模板2</div> | <div style=\"width: 33%\">模板3</div>\n--- | --- | --- | ---\n左指针 | left = 0 | left = 0 | left = 0\n右指针 | right = length - 1 | right = length | right = length - 1\n循环条件 | left <= right | left < right | left + 1 < right\n左指针移动 | left = mid + 1 | left = mid + 1 | left = mid\n右指针移动 | right = mid - 1 | right = mid | right = mid\n最终判断 | 无 | left是否在界限内，是不是target？ | left是否是target？right是不是target？\n核心区别 | 便于解决只需要通过元素本身就能判断是否为目标的问题 | 便于解决需要元素本身及邻居来判断是否为目标的问题 | 模板1、2的加强版，万能模板\n\n\n## 模板1 案例\n\n只要通过元素本身即可判断是否为目标的问题，用模板1会很方便。\n\n* [LeetCode 704. Binary Search](https://leetcode.com/problems/binary-search/)\n    > 经典二分查找法\n\n\n## 模板2 案例\n\n不仅要靠元素本身，还需要邻居才能判断是否为目标，用模板2更方便。\n\n* [LeetCode 278. First Bad Version](https://leetcode.com/problems/first-bad-version/) \n    > 处理`AA...AABB...BB`类型的问题，找出最后一个A或者第一个B。\n* [LeetCode 34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n    > 处理`AABBCCDD`类型的问题，找出B的开始和结束。\n* [LeetCode 162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\n    > 处理山峰的问题，非常典型。需要通过元素和邻居来判断指针如何移动。\n\n\n## 模板3 案例\n\n模板3是模板1、2的加强版，是一个万能二分法模板，基本上所有的二分法问题都能解决。\n有时候我们用模板2去做一些`AABB`类型的题目时，会碰到死循环，原因是左右中位数选择的问题，这个时候需要将mid换成右中位数( mid = right + left + 1 >>> 1; )，不熟练的话，你都不知道自己为什么死循环了。\n但我们用模板3，则简单无脑，所以你可以所有二分法都用模板3，反正肯定不会出错就是了。\n\n* [LintCode 183. Wood Cut](https://www.lintcode.com/problem/wood-cut/description)\n    > 这个例子如果用模板2，需要搞清楚用左右中位数的哪个，否则容易死循环，用模板3则轻松愉快。\n\n\n# 总结\n\n模板1到模板3是一个进化的关系，目的就是为了更方便的解决问题，不让自己陷入死循环。通常能用模板1解决的问题，都能用模板2解决；能用模板2解决的问题，都能用模板3解决。而且模板3是最不容易出错的写法。\n所以你可以只记住模板3的写法，它基本上能解决所有二分法问题。\n\n","tags":["binary search","algorithm","leetcode"],"categories":["Algorithm"]}]