[{"title":"特殊的二叉树","url":"/2020/Special-Binary-Tree/","content":"\n# 二叉搜索树\n\n## 特性\n\n二叉搜索树是一种特殊的二叉树，它具有这样的性质：每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。等于这个条件视情况而定，通常根据题目的要求来。\n\n由于这样的特性，我们采用中序遍历的时候，会得到一个有序的排列，所以很多二叉搜索树的问题会用到中序遍历。\n\n例子：\n\n* [LeetCode 98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) \n\n题目要求验证一个树是二叉搜索树。如果用普通的递归思想，验证左树是不是 && 验证右树是不是，会掉入题目的陷阱，即可能出现左树是二叉搜索树，右树也是，但左树有比当前节点更大的数值，或者右树有比节点更小的数字。这时候你就要额外的去记录左侧最大值和右侧最小值，它们必须小于和大于当前节点的值。\n\n这时候我们换个思路，我们用中序遍历把值都放进一个数组，这个数组是有序的，则说明这是一个合格的二叉搜索树。当然也可以优化一下，每次遍历的节点都必然比上一个遍历的节点大。\n\n```\nclass Solution {\n    // 记录上一个访问过的节点的值\n    private Integer previousNodeVal = null;\n    \n    public boolean isValidBST(TreeNode node) {\n        if (node == null) {\n            return true;\n        }\n        // 左 -> 中 -> 右，中序遍历\n        boolean checkLeft = isValidBST(node.left);\n        boolean checkSelf;\n        if (previousNodeVal == null) {\n            checkSelf = true;\n        } else {\n            // 当前节点大于上一个节点，说明\n            checkSelf = node.val > previousNodeVal;\n        }\n        // 将每次访问过的节点记录下来\n        previousNodeVal = node.val;\n        \n        boolean checkRight = isValidBST(node.right);\n\n        return checkLeft && checkSelf && checkRight;\n    }\n    \n}\n```\n\n## 查找\n\n这个没什么好说的，递归或者非递归的写法都行，思路就是根据目标相对于当前节点的大小来判断去左边还是右边找。\n\n* [LeetCode 98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) \n\n## 插入\n\n插入操作通常会有多个符合条件的结果，我通常用比较容易记忆的一种方案，就是根据需要插入的值不停的跟节点比较大小，一直找到某个节点的left或right为空的情况，然后创建一个节点放到对应的位置。\n\n* [LeetCode 701. Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/) \n\n## 删除\n\n二搜索树的删除稍微复杂一些，因为删除节点后，需要维持二叉树的性质。删除节点分为几种情况，假设有这样一个二叉搜索树：\n\n```\n     4\n   /   \\\n  2     5\n / \\     \\\n1   3     6\n```\n\n如果待删除节点有0个子树：例如我要删除节点6，直接删除即可，变成这样：\n```\n     4\n   /   \\\n  2     5\n / \\     \n1   3     \n```\n\n如果待删除节点有1个子树：例如我要删除节点5，将5的子树6放到5原本的位置，删除5即可，变成这样：\n```\n     4\n   /   \\\n  2     6\n / \\      \n1   3      \n```\n\n如果待删除节点有2个子树：例如我要删除节点4，这怎么办呢，常用的删除方法又有2种：\n\n1. **方法1**：合并删除。找到待删除节点的左边最大值节点，这里是3，然后将待删除节点的右子树合并到3下面，变成：\n    ```\n      2 \n     / \\\n    1   3\n         \\\n          5\n           \\\n            6 \n    ```\n1. **方法2**：复制删除。找到待删除节点左子树中的最大值，这里是3，复制到当前节点，这里是把4变成3，再删除被复制的节点，变成：\n    ```\n         3\n       /   \\\n      2     5\n     /       \\\n    1         6\n    ```\n\n可以看出来，方法1可能会导致树的平衡遭到破坏，这会降低二叉搜索树的效率。方法2会尽可能的维持原本的数高度，所以更推荐使用方法2删除节点。\n\n* [LeetCode 450. Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)\n    > 思路虽然容易理解，但代码写起来还是有点麻烦的，建议上手练习一下。\n\n# 红黑树\n\n假设给一个有序数组建立二叉搜索树，比如 [1,2,3,4,5]，会变成这样：\n```\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n```\n这样的话二叉搜索树就变得不平衡，效率低下，所以大佬们想了很多方法来构建一个平衡的二叉搜索树，有：\n\n* [红黑树(Red–black tree)](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)\n* [AVL树(AVL tree)](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)\n* [数堆(Treap)](https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86)\n* [伸展树(Splay tree)](https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91)\n* [加权平衡树（Weight balanced tree）](https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%9D%83%E5%B9%B3%E8%A1%A1%E6%A0%91)\n* ……\n\n这些离我们都比较遥远，很少会用到，只要有了解就可以了。\n\n里面稍微常见一点的是红黑树，红黑树具备这样的特征：\n\n* 节点是红色或黑色。\n* 根是黑色。\n* 所有叶子都是黑色（叶子是NIL节点）。\n* 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）\n* 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。\n\n理解起来有点复杂，大家可以去google一下，有很多优秀的文章讲解。\n\n例如 \n* [红黑树 - 维基百科](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)\n* [30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)\n","tags":["algorithm","leetcode","binary tree","n-ary tree","binary search tree"],"categories":["Algorithm"]},{"title":"二叉树算法从入门到精通","url":"/2020/Learning-Binary-Tree/","content":"\n# 3种遍历顺序\n\n二叉树遍历算法，根据根节点相对于左节点、右节点的不同访问顺序，分为`前序遍历(Pre-Order Traversal)`、`中序遍历(In-Order Traversal)`、`后序遍历(Post-Order Traversal)`。\n\n* 前序遍历：根节点第一个访问：根-左-右；\n* 中序遍历：根节点第二个访问：左-根-右；\n* 后序遍历：根节点最后访问：左-右-根。\n\n示例，假设有这样一个树：\n\n```\n      1\n     / \\\n    /   \\\n   2     3\n  / \\   / \\\n /   \\ /   \\\n4    5 6    7\n```\n\n* 前序遍历：1-2-4-5-3-6-7\n* 中序遍历：4-2-5-1-6-3-7\n* 后序遍历：4-5-2-6-7-3-1\n\n用递归实现的3种遍历是这样的：\n\n```\n/**\n * 这是我们的TreeNode的定义，后面所有例子用的TreeNode都是这样。\n */\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n    }\n}\n\n/**\n * 前序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    if (root.val is target) {\n        do something\n    }\n    treeTraversal(root.left);\n    treeTraversal(root.right);\n}\n\n/**\n * 中序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    treeTraversal(root.left);\n    if (root.val is target) {\n        do something\n    }\n    treeTraversal(root.right);\n}\n\n/**\n * 后序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    treeTraversal(root.left);\n    treeTraversal(root.right);\n    if (root.val is target) {\n        do something\n    }\n}\n```\n\n\n# 2种遍历策略\n\n树的遍历分为深度优先遍历和广度优先遍历。\n\n## 深度优先遍历\n\n深度优先(Depth First Search, DFS)的意思就是，先一条道走到黑，走到不能再走了，再回过头了遍历其他。\n下面用一个最简单的例子来说明不同的深度优先遍历。\n\n> [LeetCode 104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n深度优先遍历大致分为递归实现和非递归实现，递归实现又分为分治法实现和遍历法实现。\n\n### 用递归实现\n\n#### 分治法\n\n最常见，最好理解的方法，就是分治法。左右叶子节点返回它们自身的深度，取大的那个深度，+1再返回。\n\n```\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    int left = maxDepth(root.left);\n    int right = maxDepth(root.right);\n    return Math.max(left, right) + 1;\n}\n```\n\n#### 遍历法\n\n遍历法与分治法的本质区别是，分治法有个回归的过程，而遍历法没有。\n\n```\nint maxDepth;\n\npublic int maxDepth(TreeNode root) {\n    maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n    // 当前的深度为1，开始遍历\n    calculateTreeDepth(root, 1);\n    // 返回最终结果\n    return maxDepth;\n}\n\npublic void calculateTreeDepth(TreeNode treeNode, int currentDepth) {\n    if (treeNode == null) {\n        // 如果当前节点是null就什么都不做\n        return;\n    }\n    // 如果当前节点的深度大于已记录的最大深度，更新最大深度\n    if (currentDepth > maxDepth) {\n        maxDepth = currentDepth;\n    }\n    // 遍历左右子树，进入左右子树时的深度是当前深度+1，如果子树是null则不会更新maxDepth\n    calculateTreeDepth(treeNode.left, currentDepth + 1);\n    calculateTreeDepth(treeNode.right, currentDepth + 1);\n}\n```\n\n### 用非递归实现\n\n非递归（即迭代法）实现需要借助`栈`这个数据结构，实现方法比递归的麻烦一些，但很重要，一定要理解它的实现原理。\n还是以上面的计算树的最大深度为例子（其实更好的做法是广度优先遍历，这里只是为了展示非递归的实现）。\n\n\n```\npublic int maxDepthDfsNonRecursion(TreeNode root) {\n    int maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n\n    // Pair: key - TreeNode, value - int, current depth\n    Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\n    // Push root node to stack\n    stack.push(new Pair<>(root, 1));\n\n    while (!stack.isEmpty()) {\n        Pair<TreeNode, Integer> pair = stack.pop();\n        TreeNode node = pair.getKey();\n        int currentDepth = pair.getValue();\n\n        // Leaf, save the max depth\n        if (node.left == null && node.right == null && currentDepth > maxDepth) {\n            maxDepth = currentDepth;\n        }\n\n        if (node.right != null) {\n            stack.push(new Pair<>(node.right, currentDepth + 1));\n        }\n        if (node.left != null) {\n            stack.push(new Pair<>(node.left, currentDepth + 1));\n        }\n    }\n    return maxDepth;\n}\n```\n\n## 广度优先遍历\n\n广度优先(Breadth First Search, BFS)的意思就是，优先遍历当前节点的所有子节点，不管子节点还有没有孙子节点。再一层一层向下遍历。\n\n通常需要借助`队列`来完成遍历，思路是：记录当前层的数量，开始遍历，将叶子节点放入队列，当遍历的数量等于当前层数量时，说明当前层已经遍历完了；检查队列是否为空，不为空说明还有下层，继续重复刚才的操作；知道全部遍历完成。\n\n```\npublic int maxDepthBfs(TreeNode root) {\n    int maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n    // 建立队列辅助计算，并添加根元素\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    // 队列不空就开始遍历\n    while (!queue.isEmpty()) {\n        // 记录当前层一共有多少个元素\n        int currentLevelSize = queue.size();\n        // 记录已经查看了多少个元素\n        int visitedSize = 0;\n        // 开始遍历当前层\n        while (visitedSize < currentLevelSize) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                if (node.left != null) {\n                    // 有左叶子节点，则加入队列\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    // 有右叶子节点，则加入队列\n                    queue.offer(node.right);\n                }\n            }\n            // 处理当前node的值，本例中无需处理\n            // 记录我们看过一个元素了，当当前层所有元素都看过之后，会退出当前while循环\n            visitedSize++;\n        }\n        // 遍历完一层的时候，最大深度+1，如果下层还有元素，则会继续遍历\n        maxDepth++;\n    }\n    // 所有节点遍历完成，返回结果\n    return maxDepth;\n}\n```\n","tags":["algorithm","leetcode","binary tree"],"categories":["Algorithm"]},{"title":"二分查找法从入门到精通","url":"/2020/Learning-Binary-Search/","content":"\n# 二分法的本质\n\n\n二分法通常用于在有序的集合中查找目标。通过O(1)的操作，将规模为`n`的问题分解为`n/2`，最终时间复杂度是`log(n)`。通常要求做到`log(n)`的时间复杂度，基本上都是二分法。\n\n\n# 二分法的痛点\n\n\n* 死循环\n  * 二分法通过`循环条件`+`指针变化`来推进，如果这两个组合不正确，就会导致死循环。\n* 是否可以使用递归(Recursion)\n  * 使用递归时，代码会更加清晰，写法更简单。不能用递归时，写法会复杂很多。有时候需要注意问题规模，使用递归是否可能导致溢出。\n\n\n# 二分法的基本写法\n\n\n```\nprivate int binarySearch(int[] nums, int target) {\n\n    // 对数据合法性进行判断\n    int badResult = -1;     // 表示没有target或nums不合法的数字，例如-1\n    if (nums不合法) {\n        return badResult;\n    }\n\n    // 设定左右指针\n    int left = 0;\n    int right = nums.length - 1;\n\n    // 开始循环\n    while (循环条件) {\n        \n        // 设定mid，这里的小技巧是使用右减左除以2再加上左，避免溢出，更好的写法是相加后无符号右移一位\n        int mid = (right + left) >>> 1;\n        \n        // 判断mid是否是所求目标，是的话返回\n        if (nums[mid] == target) {\n            return mid;\n        }\n\n        // 不是的话，判断移动左还是右指针，将问题规模减小一半\n        if (target在左侧) {\n            移动右指针\n        } else {\n            移动左指针\n        }\n    \n    }\n\n    // 视上述循环条件和移动指针的方式，执行额外的最终判断\n    最终判断\n    // 如果最终没有满足条件的结果，返回失败\n    return badResult;\n}\n```\n\n总结一下就是通过循环，不停的移动左右指针将问题规模减半，直到解决问题。\n\n这里的难点是`循环条件`和`移动左右指针的方法`，这两者使用不同的组合会有不同的效果，使用错了会导致死循环。下面我介绍一些常见的循环条件和移动左右指针的方法的组合。\n\n\n# 二分法常见模板\n\n\n基本上所有的二分查找算法都可以用下面3种模板之一来解决。\n\n## 模板1\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length - 1\n循环条件 | left <= right\n左指针移动 | left = mid + 1\n右指针移动 | right = mid - 1\n最终判断 | 无\n\n这个模板在退出循环时，left与right会交错而过(即left - 1 == right)，此时所有可能项目都查找过了，所以不需要额外的操作。\n\n\n## 模板2\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length\n循环条件 | left < right\n左指针移动 | left = mid + 1\n右指针移动 | right = mid\n最终判断 | left是否是target？\n\n模板2的right初始值需要注意一下，是length，这是为了配合left < right这个循环条件。\n\n这个模板在退出循环的时候，一定有left == right，此时因为不满足循环条件，所以这个值还没有判断过，于是在退出循环之后，还需要判断一次left是否是target（判断right也行，因为退出循环时left必然等于right）。\n\n\n## 模板3\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length - 1\n循环条件 | left + 1 < right\n左指针移动 | left = mid\n右指针移动 | right = mid\n最终判断 | left是否是target？right是否是target？\n\n模板3在退出循环的时候，left + 1 == right，也就是查找到了最后2个项目，这两个项目没有在循环中判断过，所以最终判断时需要分别看一下left和right是否是target\n\n\n# 模板的选择\n\n上面介绍了3种模板，他们的核心区别是\n\n<div style=\"width: 80px\">项目</div> | <div style=\"width: 33%\">模板1</div> | <div style=\"width: 33%\">模板2</div> | <div style=\"width: 33%\">模板3</div>\n--- | --- | --- | ---\n左指针 | left = 0 | left = 0 | left = 0\n右指针 | right = length - 1 | right = length | right = length - 1\n循环条件 | left <= right | left < right | left + 1 < right\n左指针移动 | left = mid + 1 | left = mid + 1 | left = mid\n右指针移动 | right = mid - 1 | right = mid | right = mid\n最终判断 | 无 | left是否在界限内，是不是target？ | left是否是target？right是不是target？\n核心区别 | 便于解决只需要通过元素本身就能判断是否为目标的问题 | 便于解决需要元素本身及邻居来判断是否为目标的问题 | 模板1、2的加强版，万能模板\n\n\n## 模板1 案例\n\n只要通过元素本身即可判断是否为目标的问题，用模板1会很方便。\n\n* [LeetCode 704. Binary Search](https://leetcode.com/problems/binary-search/)\n    > 经典二分查找法\n\n\n## 模板2 案例\n\n不仅要靠元素本身，还需要邻居才能判断是否为目标，用模板2更方便。\n\n* [LeetCode 278. First Bad Version](https://leetcode.com/problems/first-bad-version/) \n    > 处理`AA...AABB...BB`类型的问题，找出最后一个A或者第一个B。\n* [LeetCode 34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n    > 处理`AABBCCDD`类型的问题，找出B的开始和结束。\n* [LeetCode 162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\n    > 处理山峰的问题，非常典型。需要通过元素和邻居来判断指针如何移动。\n\n\n## 模板3 案例\n\n模板3是模板1、2的加强版，是一个万能二分法模板，基本上所有的二分法问题都能解决。\n有时候我们用模板2去做一些`AABB`类型的题目时，会碰到死循环，原因是左右中位数选择的问题，这个时候需要将mid换成右中位数( mid = right + left + 1 >>> 1; )，不熟练的话，你都不知道自己为什么死循环了。\n但我们用模板3，则简单无脑，所以你可以所有二分法都用模板3，反正肯定不会出错就是了。\n\n* [LintCode 183. Wood Cut](https://www.lintcode.com/problem/wood-cut/description)\n    > 这个例子如果用模板2，需要搞清楚用左右中位数的哪个，否则容易死循环，用模板3则轻松愉快。\n\n\n# 总结\n\n模板1到模板3是一个进化的关系，目的就是为了更方便的解决问题，不让自己陷入死循环。通常能用模板1解决的问题，都能用模板2解决；能用模板2解决的问题，都能用模板3解决。而且模板3是最不容易出错的写法。\n所以你可以只记住模板3的写法，它基本上能解决所有二分法问题。\n\n","tags":["binary search","algorithm","leetcode"],"categories":["Algorithm"]}]