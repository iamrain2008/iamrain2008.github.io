[{"title":"Java, JavaScript, Python 常用数据结构总结","url":"/2020/Data-Structure-Different-between-Java-Javascript-and-Python/","content":"\n# 常用数据类型\n\n| Java| JavaScript| Python\n| --- | --------- | ------\n| 整数类型：byte,short,int,long<br/>浮点数类型：float,double<br/>字符类型:char<br/>布尔类型:boolean | 数字(Number): 整数,小数<br/>任意精度整数(BigInt)：可处理大整数<br/>字符串(String)：一串字符序列<br/> 布尔值(Boolean):true / false<br/>undefined:未定义或不存在<br/>null:空值<br/>代表(Symbol):实例唯一且不可改变<br/>Object:狭义object,array,function | 数值：int,float,complex<br/>字符串：str（由Unicode构成的不可变序列）<br/>布尔值：True / False (它是int的子类型)<br/>空值：None<br/>序列类型：list,tuple<br/>集合类型：set,forzenset<br/>映射类型：dict\n\n注意事项：\n\nJavaScript的数值都是64位存储，在某些特定的运算，如位运算时，才会将整数自动转成32位来计算。\n\nPython 中的除法，`//`才是其他大多数语言中的`/`\n\n\n# 常用数据结构\n\n| Java | JavaScript | Python |\n| ---- | ---------- | ------ |\n| 数组: DataType[]<br/>List: ArrayList, LinkedList<br/>Map: HashMap, LinkedHashMap, TreeMap<br/>Set: HashSet, LinkedHashSet, TreeSet<br/>Stack:Stack<br/>Queue: LinkedList(Deque), PriorityQueue | 数组: Array<br/>Map: Map<br/>Set: Set<br/>Stack: 无<br/>Queue: 无 | 序列类型：list,tuple<br/>集合类型：set,forzenset<br/>映射类型：dict<br/>Stack: queue.LifoQueue<br/>Queue: queue.Queue, queue.PriorityQueue, collections.deque\n\n## 数组 Array\n\n### Java\n\n```\n// 声明方式\n// 方式1，按部就班\ndataType[] arrayRefVar; //申明\narrayRefVar = new dataType[arraySize];  //创建\narrayRefVar[index] = value;//赋值\n\n// 方式2，直接赋值\ndataType[] arrayRefVar = new dataType[]{value0, value1, ..., valueN};  //创建\n\n// 方式3，直接赋值的简单写法\ndataType[] arrayRefVar = {value0, value1, ..., valueN};\n\n// 遍历\nfor (dataType value : arrayRefVar) {} // foreach方法\nfor (int index = 0; index < arrayRefVar.length; index++) {} // 传统fori遍历\n\n// 切片\ndataType[] sliceFromStart = Arrays.copyOf(arrayRefVar, 2);\ndataType[] sliceOfRange = Arrays.copyOfRange(arrayRefVar, 2, 4);\n\n// 排序\nArrays.sort(arrayRefVar);\n\n// 增删改查\n// 由于Java中的数组长度不可变，所以没有提供相关的增删方法，只能通过其他方式实现\n// 改\narrayRefVar[index] = newValue;  \n// 查\nArrays.binarySearch() // 适用于有序数组\n// 非有序数组只能遍历或者转List等数据结构用它们的contains()方法\n```\n\n### JavaScript\n\n数组本质上是一种特殊的对象，可以参考[网道-JavaScript教程-数组](https://wangdoc.com/JavaScript/types/array.html)\n\n```\n// 声明方式\n// 方式1，初始化给值\nvar arr = new Array(element0, element1, ..., elementN);\nvar arr = Array(element0, element1, ..., elementN);\nvar arr = [element0, element1, ..., elementN];\n\n// 初始化不给值，后续填充\nvar emp = [];  //不像java在声明的时候必须指定大小\nemp[0] = \"Casey Jones\";\nemp[1] = \"Phil Lesh\";\n\n// 与Java的区别，任何类型都可以放入数组\nvar arr = [\n  {a: 1},\n  [1, 2, 3],\n  function() {return true;}\n];\n\n// 遍历操作\nfor (const value of arr) {} // 符合大家预期的for循环。遍历的是数组内的值，可以正常响应return,break,continue\narr.forEach((value) => { console.log(value) })  // foreach遍历，不能return,break,continue\nfor (let i = 0; i < arr.length; i++) {}  //fori循环，用let或var关键字，可以正常return,break,continue\nfor (const index in arr) () // 不要用这种方法。遍历的是索引；看起来可以，但实际上不能return、break、continue\n\n// 切片\narr.slice(start);\narr.slice(start, end);\n\n//排序\narr.sort();\n\n// 增删改查\narr.push(newValue) // 增加到末尾\narr.pop()   // 弹出最后一个元素，改变长度\n\narr.unshift(newValue) // 增加到开头,index=0的位置\narr.shift() // 删除第一个元素，改变长度\n\ndelete arr[index] // 删除后当前位置变undefined，不改变长度\n\narr[index] = newValue // 改变index的值\narr.concat(newArr) // 拼接2个数组\n\narr.indexOf(target) //target所在index，不包含返回-1\narr.includes(target)   // 是否包含target，返回boolean\n\n// splice万能方法\nvar arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\n// 从索引2开始删除3个元素,然后再添加两个元素:\narr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n// 只删除,不添加:\narr.splice(2, 2); // ['Google', 'Facebook']\narr; // ['Microsoft', 'Apple', 'Oracle']\n// 只添加,不删除:\narr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n```\n\n### Python\n\nPython通常用`元组`(tuple，不可变的集合)或`列表`(List，可变的集合)来达到其他语言数组的效果。他们的[通用序列操作](https://docs.python.org/zh-cn/3.7/library/stdtypes.html#common-sequence-operations)。\n\n```\n# 元组\ntheTuple = (\"apple\", \"banana\", \"cherry\")\nspecialTuple = (1,) # 后面要有逗号,避免定义的是数字1，也就是避免括号运算符与数学意义上的括号混淆\n# 列表\nfruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\n\n# 遍历\nfor fruit in fruits:\n    # for in 遍历\n    print(fruit)\n\nfor index in range(0, len(fruits), 2):\n    # 借助range(start, end[, step])遍历\n    print(fruits[index])\n\n# 切片操作\nnewTuple = theTuple[0:4:1] //起始，终点（不包含），步长\n\n# 排序\nfruits.sort()\n\n# 增删改查\nfruits.append('pear') # 只能添加1个元素，如果参数是['pear']，那么就会在末尾添加一个列表['pear']而不是元素'pear'\nfruits.extend('pear')   # 末尾添加元素'pear'\nfruits.extend(['pear']) # 末尾添加元素'pear'\nfruits.extend(['pear','peach']) # 末尾添加元素'pear','peach'\nfruits += ['pear', 'peach'] # 等同于fruits.extend()方法\nfruits.insert(2,'peach') # 在index为2的位置插入'peach'，与append一样只能插入一个元素\ndel fruits[index]\ndel fruits[start:end:step]\nfruits.remove('pear')   # 删除'pear'元素，如果没有会报错\nfruits.pop([index]) # index默认为-1，即最后一个元素\n'pear' in fruits # 检测是否包含元素\n```\n\n## 列表 List\n\n### Java\n  \n```\nArrayList<Integer> list = new ArrayList<>();    // 内部以数组实现\nlist.add(100);\nlist.add(200);\nlist.get(0);\nlist.set(0, 150);   // index可能越界\nlist.remove(1);\nlist.remove(Integer.valueOf(150));  // 直接写remove(100)会当成index处理，这里需要一个Integer对象\n\nLinkedList<Integer> linkedList = new LinkedList<>();    // 内部以链表实现\n```\n\n### JavaScript\n\n同`Array`，见上一节`数组`。\n\n### Python\n\n同`list`。见上一节`数组`。\n\n## 键值对 Map\n\n### Java\n\n```\n// 内部以Node<K,V>[]数组存储数\n// 声明\nMap<String, String> map = new HashMap<>();\n\n// 基本操作\nmap.put(\"a\", \"this is A\");\nmap.put(\"a\", \"this is new A\");\nmap.containsKey(\"a\");           // true\nmap.containsValue(\"this is A\"); // false\nmap.remove(\"b\");                // return null\nmap.get(\"a\");                   // return \"this is new A\"\nmap.size();                     // return 1\n\n// 遍历\nfor (Map.Entry<String, String> item : map.entrySet()) { // 遍历键值对\n    System.out.println(item.getKey());\n    System.out.println(item.getValue());\n}\n\nfor (String key : map.keySet()) {                       // 遍历键\n    System.out.println(key);\n}\n\nfor (String value : map.values()) {                     // 遍历值\n    System.out.println(value);\n}\n```\n\n### JavaScript\n\n```\n// 声明方法\nlet myMap = new Map();\n\nlet keyObj = {};\nlet keyFunc = function() {};\nlet keyString = 'a string';\n \n// 添加、修改\nmyMap.set(keyString, \"和键'a string'关联的值\");\nmyMap.set(keyObj, \"和键keyObj关联的值\");\nmyMap.set(keyFunc, \"和键keyFunc关联的值\");\nmyMap.set(NaN, \"not a number\");   // NaN作为键的时候视为相同\n \nmyMap.size; // 4\n \n// 读取值\nmyMap.get(keyString);    // \"和键'a string'关联的值\"\nmyMap.get(keyObj);       // \"和键keyObj关联的值\"\nmyMap.get(keyFunc);      // \"和键keyFunc关联的值\"\nmyMap.get(Number(\"foo\"));// \"not a number\"\n \nmyMap.get('a string');   // \"和键'a string'关联的值\"，因为keyString === 'a string'\nmyMap.get({});           // undefined, 因为keyObj !== {}\nmyMap.get(function() {});// undefined, 因为keyFunc !== function () {}\n\n// 遍历\nfor(let [key, value] of myMap) {\n    console.log(`${key} => ${value}`)\n}\n\nfor (let item of myMap) {\n    console.log(Array.isArray(item)) // true，可以看出与上例本质一样\n    console.log(`${item[0]} => ${item[1]}`)\n}\n```\n\n更多详情请看[Mozilla关于Map的文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)。\n\n### Python\n\n```\n# Python中的Map就是dict\n# 声明方法\na = dict(one=1, two=2, three=3)\nb = {'one': 1, 'two': 2, 'three': 3}\nc = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\nd = dict([('two', 2), ('one', 1), ('three', 3)])\ne = dict({'three': 3, 'one': 1, 'two': 2})\n# 上述方法等价，即 a == b == c == d == e 为 True\n\n# 添加元素\na['a'] = 'A'\na['c'] = 'C'\n# 修改元素\na['a'] = 'AA'\nd.update({'a': 'AAA', 'b':'BBB'})  # 可以批量更新，key已经存在会被覆盖\n# 读取元素\na['d']      # 读取错误，触发KeyError。这种方式需要通过 key in a 来判断是否存在对应key\na.get('d')  # 返回None，不会触发KeyError\n# 删除元素\ndel a['a']  # 删除对应元素，如果不存在，会触发KeyError\na.clear()   # 删除所有\n\nlen(a)  // 获取长度\n\n# 遍历\nfor key in list(d):         // 遍历所有key\n    print(key)\n\nfor key in d.keys():        // 与上面的等价\n    print(key)\n\nfor value in d.values():    // 遍历所有值\n    print(value)\n    \nfor key,value in d.items(): // 遍历所有键值对\n    print(key + \" => \" + value)\n```\n\n更多详情请看[Python官方文档: 映射类型 dict](https://docs.python.org/zh-cn/3.7/library/stdtypes.html#mapping-types-dict)\n\n## 集合 Set\n\n\n集合间运算涉及到的一些名词，交集、并集应该好理解，相对补集、对称差可能不太好理解，这里附上一些资料：\n\n* [集合 - 补集](https://zh.wikipedia.org/wiki/%E8%A1%A5%E9%9B%86)\n* [集合 - 对称差](https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%B7%AE)\n\n### Java\n\n```\n// HashSet内部实现是用的HashMap，其实就是把值当key放到HashMap里\nSet<String> set = new HashSet<>();\nset.add(\"A\");\nset.add(\"B\");\nset.add(\"C\");\nset.contains(\"C\");  // false\nset.remove(\"B\"); // true\nset.size();         // 2\n\n// 遍历\n// 方式1\nfor (String value : set) {\n    System.out.println(value);\n}\n\n// 方式2\nIterator<String> it = set.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}\n\n// 集合间运算\nSet<String> set1 = new HashSet<>();\nset1.add(\"A\");\nset1.add(\"B\");\nset1.add(\"C\");\nSet<String> set2 = new HashSet<>();\nset2.add(\"D\");\nset2.add(\"B\");\nset2.add(\"C\");\n// 交集\nset1.retainAll(set2); // set1 = \"B\",\"C\"\n// 并集\nset1.addAll(set2);    // set1 = \"A\",\"B\",\"C\",\"D\"\n// 相对补集（差集）\nset1.removeAll(set2); // set1 = \"A\"\n```\n\n### JavaScript\n\n```\n// 声明\nlet mySet = new Set();\n\n// 添加元素\nmySet.add(1); // Set [ 1 ]\nmySet.add(5); // Set [ 1, 5 ]\nmySet.add(5); // Set [ 1, 5 ]\nmySet.add(\"some text\"); // Set [ 1, 5, \"some text\" ]\nlet o = {a: 1, b: 2};\nmySet.add(o);\nmySet.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题\n\n// 检查元素\nmySet.has(1); // true\nmySet.has(3); // false\nmySet.has(5);              // true\nmySet.has(Math.sqrt(25));  // true\nmySet.has(\"Some Text\".toLowerCase()); // true\nmySet.has(o); // true\n\n// 删除元素\nmySet.delete(5);  // true,  从set中移除5\nmySet.has(5);     // false, 5已经被移除\n\n// Set长度\nmySet.size; // 4, 刚刚移除一个值\n\nconsole.log(mySet); // Set {1, \"some text\", Object {a: 1, b: 2}, Object {a: 1, b: 2}}\n// 遍历\n\n// 按顺序输出：1, \"some text\", {\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2}\nfor (let item of mySet) console.log(item);\n\n// 按顺序输出：1, \"some text\", {\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2} \nfor (let item of mySet.keys()) console.log(item);\n \n// 按顺序输出：1, \"some text\", {\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2} \nfor (let item of mySet.values()) console.log(item);\n\n// 按顺序输出：1, \"some text\", {\"a\": 1, \"b\": 2}, {\"a\": 1, \"b\": 2} \n//(键与值相等)\nfor (let [key, value] of mySet.entries()) console.log(key);\n\n// 用forEach迭代\nmySet.forEach(function(value) {\n  console.log(value);\n});\n```\n[Mozilla - Set相关文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)\n\n### Python\n\n```\n# 声明\nset0 = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} // {'apple', 'pear', 'banana', 'orange'}\nset1 = set()\nset2 = set('apple') // {'a', 'l', 'p', 'e'}\nset3 = {x for x in 'abcd' if x not in 'cdef'} # 集合推导式,结果是{'a', 'b'}\n\n# 添加元素\nset3.add('c')  # 只能添加一个元素\n# update 可以添加多个元素，也可以添加所有Iterable，例如list,tuple,set,dict,str\nset3.update('d', 'e')\nset3.update(['f', 'g'])\nset3.update({'f': 'd', 'g': 'e'})   # 添加的是keys\nset3.update({'f': 'd', 'g': 'e'}.values()) # 添加values\n\n# 检查元素\n'a' in set3 # True or False\n\n# 删除元素\nset3.remove('a')  # 移除对应元素，不存在会报错\nset3.discard('a') # 与remove一样，但不会报KeyError错误\nset3.pop()        # 随机删除一个元素\nset3.clear()      # 清空\n\n# 获取大小\nlen(set1)\n\n# 两集合间的运算\nset4 = set('abcd')\nset5 = set('cde')\nset4 - set5 # 相对补集（差集） {'a', 'b'}\nset4 | set5 # 并集 {'d', 'c', 'e', 'a', 'b'}\nset4 & set5 # 交集 {'d', 'c'}\nset4 ^ set5 # 两个集合的对称差 {'e', 'b', 'a'}\n```\n\n## 栈 Stack\n\n### Java\n\n```\n// 声明。继承自Vector。实际以数组存储数据。\nStack<Integer> stack = new Stack<>();\n\n// 增加\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// 检查顶部\nstack.peek();\n\n// 取出\nstack.pop();\n\n// 查找\nstack.search(2);\n\n// 判空\nstack.empty();\n\n// 长度\nstack.size();\n```\n\n### JavaScript\n\n```\n// 使用第三方或者自行基于数组等实现\n```\n\n### Python\n\n```\nimport queue\n\n# 后进先出队列，可以当栈用\nlifoQueue = queue.LifoQueue()\n# 添加元素，相当于Java中的push()方法\nlifoQueue.put(1)\nlifoQueue.put(2)\nlifoQueue.put(3)\n# 获取元素，取元素前先判空，否则会block等待有元素加入，直到超时报错。或者也可以设置block为false，队列空就会直接报Empty错误\n# 这里连续get可以获得3,2,1。相当于Java的pop()方法\nlifoQueue.get()\n# 获取队列大小（多线程时不可靠）\nlifoQueue.qsize()\n```\n\n## 队列 Queue\n\n### Java\n\n```\n// 普通的队列\nvar queue = new LinkedList<AbstractMap.SimpleEntry<Integer, Integer>>();\n// 优先级队列。声明时需要设置对比器，比如这里用value排序\nvar priorityQueue = new PriorityQueue<AbstractMap.SimpleEntry<Integer, Integer>>(\n    Comparator.comparingInt(AbstractMap.SimpleEntry::getValue));\n\n// 添加元素\nvar item1 = new AbstractMap.SimpleEntry<>(1, 10);\nvar item2 = new AbstractMap.SimpleEntry<>(2, 8);\nvar item3 = new AbstractMap.SimpleEntry<>(3, 9);\npriorityQueue.offer(item1);\npriorityQueue.offer(item2);\npriorityQueue.offer(item3);\nqueue.offer(item1);\nqueue.offer(item2);\nqueue.offer(item3);\n\n// 获取元素,poll()和peek()\npriorityQueue.poll();   // 此时poll()执行3次得到的item2,item3,item1\nqueue.poll();           // 此时poll()执行3次得到的item1,item2,item3\n/*\n普通队列默认是添加到队列后面，从前面取元素，即\npeek() = peekFirst()\npoll() = pollFirst()\noffer() = offerLast()\n\n由于LinkedList实现了Deque，支持双向列表，所以还支持这些操作：\npeekLast(), pollLast(), offerFirst()等\n */\nqueue.peekLast();\n```\n\n### JavaScript\n\n```\n// 没有现成的，只能自定义或使用第三方\n```\n\n### Python\n\n```\nimport queue\n\n# 声明普通队列(先进先出)\nfifoQueue = queue.Queue()\n# 添加元素，相当于Java中的offer\nfifoQueue.put(1)\nfifoQueue.put(2)\nfifoQueue.put(3)\n# 获取元素，取元素前先判空，否则会block等待有元素加入，直到超时报错。或者也可以设置block为false，队列空就会直接报Empty错误\n# 这里连续get可以获得1,2,3。相当于Java中的poll()\nfifoQueue.get()\n# 获取队列大小（多线程时不可靠）\nfifoQueue.qsize()\n\n\n# 双向队列。Deque 支持线程安全，内存高效添加(append)和弹出(pop)，\n# 从两端都可以，两个方向的大概开销都是 O(1) 复杂度\nfrom collections import deque\nd = deque()\n# 在右端增加元素\nd.append(1)  # 1,\nd.append(2)  # 1,2\n# 在左端增加元素\nd.appendleft(0)  # 0,1,2\n# 在末尾弹出元素\nd.pop()  # 0,1\n# 在队首弹出元素\nd.popleft()  # 1,\n\n\n# 声明优先队列\npriorityQueue = queue.PriorityQueue()\n# 添加元素，添加的item必须是可以比较的，会以从小到大的顺序排列\npriorityQueue.put(('a', 2))\npriorityQueue.put(('a', 1))\npriorityQueue.put(('b', 3))\npriorityQueue.put(('c', 2))\n# 获取元素\nwhile priorityQueue.qsize() != 0:\n    print(priorityQueue.get())  # 输出 ('a', 1) ('a', 2) ('b', 3) ('c', 2)\n# 获取队列大小（多线程时不可靠）\npriorityQueue.qsize()\n```\n","tags":["Java","JavaScript","Python"],"categories":["Language","Algorithm","Data Structure"]},{"title":"宽度优先搜索小结","url":"/2020/Learning-Breadth-First-Search/","content":"\n\n宽度优先搜索（Breadth First Search）通常是指图（树也是图）的一种查找顺序。它从某个节点开始，每次都遍历完当前节点可以直接到达的所有节点，再继续遍历下一层节点，一层一层的搜索。\n\n# 二叉树的宽度优先搜索\n\n例如我有一个二叉树：\n\n```\n      1\n     / \\\n    /   \\\n   2     3\n  / \\   / \\\n /   \\ /   \\\n4    5 6    7\n```\n\n我的遍历顺序是1->2->3->4->5->6->7，这就是一种宽度优先搜索。通常树的宽度优先搜索会使用`队列`来辅助，具体可以看之前的这篇文章[二叉树算法 - 广度优先遍历](https://huangyufei.cn/2020/Learning-Binary-Tree/#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86)\n\n树的宽度优先遍历通常用来解决\n\n1. 深度先关问题\n2. 需要层级遍历的问题（例如树的序列化和反序列化）\n\n# 图的宽度优先搜索\n\n## 图的基本表示方法\n\n我们通常用2种方法来表示图：\n\n1. 邻接矩阵(Adjacency Matrix)\n2. 邻接表(Adjacency List)\n\n### 邻接矩阵\n\n通常用`二维数组`来实现。\n\n* 有 n 个节点的图需要有一个 n × n 大小的矩阵\n* 在一个无权图中，矩阵坐标中每个位置值为 1 代表两个点是相连的，0 表示两点是不相连的\n* 在一个有权图中，矩阵坐标中每个位置值代表该两点之间的权重，0 表示该两点不相连\n* 在无向图中，邻接矩阵关于对角线相等\n\n### 邻接表\n\n通常用`一维数组`+`链表`来实现。\n\n* 对于每个点，存储着一个链表，用来指向所有与该点直接相连的点\n* 对于有权图来说，链表中元素值对应着权重\n\n### 示例\n\n无向无权图：\n\n![UndirectedUnweightedGraph](https://huangyufei.cn/img/LearningBreadthFirstSearch-UndirectedUnweighted.png)\n\n无向有权图：\n\n![UndirectedWeightedGraph](https://huangyufei.cn/img/LearningBreadthFirstSearch-UndirectedWeighted.png)\n\n有向无权图：\n![DirectedUnweightedGraph](https://huangyufei.cn/img/LearningBreadthFirstSearch-DirectedUnweighted.png)\n\n有向有权图：\n\n基于无向有权图改一下就行了。\n\n## 宽度优先搜索的常见问题\n\n图的搜索算法中，经常会用到宽度优先搜索。例如图的层级遍历、在简单图中寻找最短路径、处理一些由点及面的问题、拓扑排序等，都合适用宽度优先搜索来解决。\n\n* [LeetCode 133. Clone Graph](https://leetcode.com/problems/clone-graph/)\n    > 克隆图。可以采用宽搜，对原始图进行层级遍历。\n\n```\n// 这题还有很多其他方法，这里展示宽搜的方法\npublic Node cloneGraph(Node node) {\n    if (node == null) {\n        return null;\n    }\n    // 存放 <原始、复制> 节点的map\n    HashMap<Node, Node> instances = new HashMap<>();\n    // 存放已处理过邻居的节点，避免图中的环造成死循环\n    HashSet<Node> processed = new HashSet<>();\n    // 队列，用于宽度优先搜索\n    Queue<Node> queue = new LinkedList<>();\n    // 节点放入队列准备开始遍历\n    queue.offer(node);\n    // 存储对应的复制节点\n    instances.put(node, new Node(node.val));\n    // 开始宽搜\n    while (!queue.isEmpty()) {\n        Node origin = queue.poll();\n        Node copy = instances.get(origin);\n        // 如果节点没有处理过，且有邻居，开始复制邻居\n        if (!processed.contains(origin) && origin.neighbors != null && origin.neighbors.size() > 0) {\n            // 遍历邻居节点\n            for (int i = 0; i < origin.neighbors.size(); i++) {\n                Node neighbor = origin.neighbors.get(i);\n                Node copyNeighbor;\n                // 如果map中有，用已存在的实例，否则new一个新的，并放入map\n                if (instances.containsKey(neighbor)) {\n                    copyNeighbor = instances.get(neighbor);\n                } else {\n                    copyNeighbor = new Node(neighbor.val);\n                    instances.put(neighbor, copyNeighbor);\n                }\n                copy.neighbors.add(copyNeighbor);\n                // 将邻居节点放入队列，之后继续处理邻居节点的邻居们\n                queue.offer(neighbor);\n            }\n        }\n        processed.add(origin);\n    }\n    // 返回入参对应的复制节点\n    return instances.get(node);\n}\n```\n\n* [LeetCode 210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)\n    > 课程表。经典拓扑排序问题，可以用宽搜解决。\n    > 拓扑排序的通用思路是：\n    <br />1.找出所有入度为0的节点，放入结果。\n    <br />2.将这些节点与邻居的边删除，这样它们的邻居的入度就会减少1。\n    <br />3.重复过程1，直到不能再继续。\n    <br />这时如果结果的数量与数据集数量一样，说明正常的完成了拓扑排序，否则说明有环，无法完成拓扑排序。\n\n```\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    // 用于统计入度\n    HashMap<Integer, Integer> indegree = new HashMap<>();\n    // 邻接表，用于获取有哪些后继\n    HashMap<Integer, ArrayList<Integer>> graph = new HashMap<>();\n    // 统计入度并构造邻接表\n    for (int i = 0; i < prerequisites.length; i++) {\n        int parent = prerequisites[i][1];\n        int child = prerequisites[i][0];\n        // 统计入度\n        indegree.put(child, indegree.getOrDefault(child, 0) + 1);\n        // 构造邻接表\n        if (graph.containsKey(parent)) {\n            graph.get(parent).add(child);\n        } else {\n            ArrayList<Integer> list = new ArrayList<>();\n            list.add(child);\n            graph.put(parent, list);\n        }\n    }\n    // 将入度为0的节点加入队列\n    Queue<Integer> order = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (!indegree.containsKey(i)) {\n            order.offer(i);\n        }\n    }\n    // 用于存储结果\n    ArrayList<Integer> result = new ArrayList<>();\n    // 开始宽度优先搜索\n    while (!order.isEmpty()) {\n        int parent = order.poll();\n        // 存入结果\n        result.add(parent);\n        // 通过邻接表中的找到所有邻居，并将它们的入度减少1，减少后如果变为0则放入队列用于下轮遍历\n        if (graph.containsKey(parent)) {\n            ArrayList<Integer> children = graph.get(parent);\n            for (int i = 0; i < children.size(); i++) {\n                int child = children.get(i);\n                indegree.put(child, indegree.get(child) - 1);\n                if (indegree.get(child) == 0) {\n                    order.offer(child);\n                }\n            }\n        }\n    }\n    // 结果少于预期数目，说明有环，无法完成\n    if (result.size() != numCourses) {\n        return new int[0];\n    }\n    // 将结果转换成数组返回\n    int[] finalResult = new int[result.size()];\n    for (int i = 0; i < result.size(); i++) {\n        finalResult[i] = result.get(i);\n    }\n    return finalResult;\n}\n```\n\n# 矩阵宽度优先搜索\n\n涉及矩阵搜索的题目，宽搜也经常应用。此类题目视情况用宽搜或深搜，思路就是把它当成图来处理，只是把图中的节点的表示方法换成了矩阵中的横竖坐标表示。\n\n* [LeetCode 200. Number of Islands](https://leetcode.com/problems/number-of-islands/)\n    > 岛屿数量\n\n```\npublic int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0 || grid[0].length == 0) {\n        return 0;\n    }\n    // 记录已经添加过队列的节点\n    HashSet<String> alreadyInQueue = new HashSet<>();\n    // 最终结果\n    int islandCount = 0;\n    // 开始逐行遍历，碰到'1'的节点时，通过宽搜，将它和它的所有邻居改成非'1'的值；\n    // 然后继续遍历，每次找到'1'就意味着发现一个岛屿\n    for (int i = 0; i < grid.length; i++) { // 行\n        for (int j = 0; j < grid[i].length; j++) { // 列\n            // 查找'1'\n            if ('1' == grid[i][j]) {\n                ++islandCount;  // 岛屿数量增1\n                /*\n                开始搜索grid[i][j]的所有邻居，直到无法找到'1'时，\n                这里用递归方法写更简单，但这里给大家展示一下非递归的思路。\n                */\n                // 用于宽搜的队列\n                Queue<SimpleEntry<Integer, Integer>> queue = new LinkedList<>();\n                // 将发现的节点加入队列\n                queue.offer(new SimpleEntry<>(i, j));\n                // 采用这种方法可能碰到一个问题是，某个点是同一层节点的公共邻居，这样就会被重复添加到队列，\n                // 所以这里用一个HashSet记录已经添加到queue中的节点，避免重复添加\n                alreadyInQueue.add(i + \"-\" + j);\n                // 开始宽搜\n                while (!queue.isEmpty()) {\n                    SimpleEntry<Integer, Integer> item = queue.poll();\n                    int m = item.getKey();  // 行数\n                    int n = item.getValue();// 列数\n                    grid[m][n] = '2'; // 标记为1以外的char即可\n                    // 上方的邻居\n                    addToQueue(queue, alreadyInQueue, grid, m - 1, n);\n                    // 右边的邻居\n                    addToQueue(queue, alreadyInQueue, grid, m, n + 1);\n                    // 下方的邻居\n                    addToQueue(queue, alreadyInQueue, grid, m + 1, n);\n                    // 左边的邻居\n                    addToQueue(queue, alreadyInQueue, grid, m, n - 1);\n                }\n            }\n        }\n    }\n    return islandCount;\n}\n\nprivate void addToQueue(Queue<SimpleEntry<Integer, Integer>> targetQueue, HashSet<String> alreadyInQueueFlag,\n                        char[][] grid, int m, int n) {\n    if (m >= 0 && m < grid.length && n >= 0 && n < grid[0].length\n            && grid[m][n] == '1' && !alreadyInQueueFlag.contains(m + \"-\" + n)) {\n        targetQueue.offer(new SimpleEntry<>(m, n));\n        alreadyInQueueFlag.add(m + \"-\" + n);\n    }\n}\n```\n\n------\n\n关于“图的基本表示方法”，参考来源：\n\n* [数据结构与算法-图论](https://zhuanlan.zhihu.com/p/25498681)\n* [Graph Algorithms](https://www-users.cs.umn.edu/~karypis/parbook/Lectures/AG/chap10_slides.pdf)\n","tags":["algorithm","leetcode","BFS"],"categories":["Algorithm"]},{"title":"特殊的二叉树","url":"/2020/Special-Binary-Tree/","content":"\n# 二叉搜索树\n\n## 特性\n\n二叉搜索树是一种特殊的二叉树，它具有这样的性质：每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。等于这个条件视情况而定，通常根据题目的要求来。\n\n由于这样的特性，我们采用中序遍历的时候，会得到一个有序的排列，所以很多二叉搜索树的问题会用到中序遍历。\n\n例子：\n\n* [LeetCode 98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) \n\n题目要求验证一个树是二叉搜索树。如果用普通的递归思想，验证左树是不是 && 验证右树是不是，会掉入题目的陷阱，即可能出现左树是二叉搜索树，右树也是，但左树有比当前节点更大的数值，或者右树有比节点更小的数字。这时候你就要额外的去记录左侧最大值和右侧最小值，它们必须小于和大于当前节点的值。\n\n这时候我们换个思路，我们用中序遍历把值都放进一个数组，这个数组是有序的，则说明这是一个合格的二叉搜索树。当然也可以优化一下，每次遍历的节点都必然比上一个遍历的节点大。\n\n```\nclass Solution {\n    // 记录上一个访问过的节点的值\n    private Integer previousNodeVal = null;\n    \n    public boolean isValidBST(TreeNode node) {\n        if (node == null) {\n            return true;\n        }\n        // 左 -> 中 -> 右，中序遍历\n        boolean checkLeft = isValidBST(node.left);\n        boolean checkSelf;\n        if (previousNodeVal == null) {\n            checkSelf = true;\n        } else {\n            // 当前节点大于上一个节点，说明合法\n            checkSelf = node.val > previousNodeVal;\n        }\n        // 将每次访问过的节点记录下来\n        previousNodeVal = node.val;\n        \n        boolean checkRight = isValidBST(node.right);\n\n        return checkLeft && checkSelf && checkRight;\n    }\n    \n}\n```\n\n## 查找\n\n这个没什么好说的，递归或者非递归的写法都行，思路就是根据目标相对于当前节点的大小来判断去左边还是右边找。\n\n* [LeetCode 98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) \n\n## 插入\n\n插入操作通常会有多个符合条件的结果，我通常用比较容易记忆的一种方案，就是根据需要插入的值不停的跟节点比较大小，一直找到某个节点的left或right为空的情况，然后创建一个节点放到对应的位置。\n\n* [LeetCode 701. Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/) \n\n## 删除\n\n二搜索树的删除稍微复杂一些，因为删除节点后，需要维持二叉树的性质。删除节点分为几种情况，假设有这样一个二叉搜索树：\n\n```\n     4\n   /   \\\n  2     5\n / \\     \\\n1   3     6\n```\n\n### 待删除节点有0个子树\n\n例如我要删除节点6，直接删除即可，变成这样：\n\n```\n     4\n   /   \\\n  2     5\n / \\     \n1   3     \n```\n\n### 待删除节点有1个子树\n\n例如我要删除节点5，将5的子树6放到5原本的位置，删除5即可，变成这样：\n\n```\n     4\n   /   \\\n  2     6\n / \\      \n1   3      \n```\n\n### 待删除节点有2个子树\n\n还是这棵树，例如我要删除节点4，这怎么办呢，常用的删除方法又有2种：\n\n```\n     4\n   /   \\\n  2     5\n / \\     \\\n1   3     6\n```\n\n1. **方法1**：合并删除。找到待删除节点的左边最大值节点，这里是3，然后将待删除节点的右子树合并到3下面，变成：\n    ```\n      2 \n     / \\\n    1   3\n         \\\n          5\n           \\\n            6 \n    ```\n2. **方法2**：复制删除。找到待删除节点左子树中的最大值，这里是3，复制到当前节点，这里是把4变成3，再删除被复制的节点，变成：\n    ```\n         3\n       /   \\\n      2     5\n     /       \\\n    1         6\n    ```\n\n可以看出来，方法1可能会导致树的平衡遭到破坏，这会降低二叉搜索树的效率。方法2会尽可能的维持原本的数高度，所以更推荐使用方法2删除节点。\n\n* [LeetCode 450. Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)\n    > 思路虽然容易理解，但代码写起来还是有点麻烦的，建议上手练习一下。\n\n# 红黑树\n\n假设给一个有序数组建立二叉搜索树，比如 [1,2,3,4,5]，会变成这样：\n```\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n```\n这样的话二叉搜索树就变得不平衡，效率低下，所以大佬们想了很多方法来构建一个平衡的二叉搜索树，有：\n\n* [红黑树(Red–black tree)](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)\n* [AVL树(AVL tree)](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)\n* [数堆(Treap)](https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86)\n* [伸展树(Splay tree)](https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91)\n* [加权平衡树（Weight balanced tree）](https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%9D%83%E5%B9%B3%E8%A1%A1%E6%A0%91)\n* ……\n\n这些离我们都比较遥远，很少会用到，只要有了解就可以了。\n\n里面稍微常见一点的是红黑树，红黑树具备这样的特征：\n\n* 节点是红色或黑色。\n* 根是黑色。\n* 所有叶子都是黑色（叶子是NIL节点）。\n* 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）\n* 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。\n\n理解起来有点复杂，大家可以去google一下，有很多优秀的文章讲解。\n\n例如 \n* [红黑树 - 维基百科](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)\n* [30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)\n","tags":["algorithm","leetcode","binary tree","n-ary tree","binary search tree"],"categories":["Algorithm","Data Structure"]},{"title":"二叉树算法总结","url":"/2020/Learning-Binary-Tree/","content":"\n# 3种遍历顺序\n\n二叉树遍历算法，根据根节点相对于左节点、右节点的不同访问顺序，分为`前序遍历(Pre-Order Traversal)`、`中序遍历(In-Order Traversal)`、`后序遍历(Post-Order Traversal)`。\n\n* 前序遍历：根节点第一个访问：根-左-右；\n* 中序遍历：根节点第二个访问：左-根-右；\n* 后序遍历：根节点最后访问：左-右-根。\n\n示例，假设有这样一个树：\n\n```\n      1\n     / \\\n    /   \\\n   2     3\n  / \\   / \\\n /   \\ /   \\\n4    5 6    7\n```\n\n* 前序遍历：1-2-4-5-3-6-7\n* 中序遍历：4-2-5-1-6-3-7\n* 后序遍历：4-5-2-6-7-3-1\n\n用递归实现的3种遍历是这样的：\n\n```\n/**\n * 这是我们的TreeNode的定义，后面所有例子用的TreeNode都是这样。\n */\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n    }\n}\n\n/**\n * 前序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    if (root.val is target) {\n        do something\n    }\n    treeTraversal(root.left);\n    treeTraversal(root.right);\n}\n\n/**\n * 中序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    treeTraversal(root.left);\n    if (root.val is target) {\n        do something\n    }\n    treeTraversal(root.right);\n}\n\n/**\n * 后序遍历\n */\npublic void treeTraversal(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    treeTraversal(root.left);\n    treeTraversal(root.right);\n    if (root.val is target) {\n        do something\n    }\n}\n```\n\n\n# 2种遍历策略\n\n树的遍历分为深度优先遍历和宽度优先遍历。\n\n## 深度优先遍历\n\n深度优先(Depth First Search, DFS)的意思就是，先一条道走到黑，走到不能再走了，再回过头了遍历其他。\n下面用一个最简单的例子来说明不同的深度优先遍历。\n\n* [LeetCode 104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n深度优先遍历大致分为递归实现和非递归实现，递归实现又分为分治法实现和遍历法实现。\n\n### 用递归实现\n\n#### 分治法\n\n最常见，最好理解的方法，就是分治法。左右叶子节点返回它们自身的深度，取大的那个深度，+1再返回。\n\n```\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    int left = maxDepth(root.left);\n    int right = maxDepth(root.right);\n    return Math.max(left, right) + 1;\n}\n```\n\n#### 遍历法\n\n遍历法与分治法的本质区别是，分治法有个回归的过程，而遍历法没有。\n\n```\nint maxDepth;\n\npublic int maxDepth(TreeNode root) {\n    maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n    // 当前的深度为1，开始遍历\n    calculateTreeDepth(root, 1);\n    // 返回最终结果\n    return maxDepth;\n}\n\npublic void calculateTreeDepth(TreeNode treeNode, int currentDepth) {\n    if (treeNode == null) {\n        // 如果当前节点是null就什么都不做\n        return;\n    }\n    // 如果当前节点的深度大于已记录的最大深度，更新最大深度\n    if (currentDepth > maxDepth) {\n        maxDepth = currentDepth;\n    }\n    // 遍历左右子树，进入左右子树时的深度是当前深度+1，如果子树是null则不会更新maxDepth\n    calculateTreeDepth(treeNode.left, currentDepth + 1);\n    calculateTreeDepth(treeNode.right, currentDepth + 1);\n}\n```\n\n### 用非递归实现\n\n非递归（即迭代法）实现需要借助`栈`这个数据结构，实现方法比递归的麻烦一些，但很重要，一定要理解它的实现原理。\n还是以上面的计算树的最大深度为例子（其实更好的做法是宽度优先遍历，这里只是为了展示非递归的实现）。\n\n\n```\npublic int maxDepthDfsNonRecursion(TreeNode root) {\n    int maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n\n    // Pair: key - TreeNode, value - int, current depth\n    Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\n    // Push root node to stack\n    stack.push(new Pair<>(root, 1));\n\n    while (!stack.isEmpty()) {\n        Pair<TreeNode, Integer> pair = stack.pop();\n        TreeNode node = pair.getKey();\n        int currentDepth = pair.getValue();\n\n        // Leaf, save the max depth\n        if (node.left == null && node.right == null && currentDepth > maxDepth) {\n            maxDepth = currentDepth;\n        }\n\n        if (node.right != null) {\n            stack.push(new Pair<>(node.right, currentDepth + 1));\n        }\n        if (node.left != null) {\n            stack.push(new Pair<>(node.left, currentDepth + 1));\n        }\n    }\n    return maxDepth;\n}\n```\n\n## 宽度优先遍历\n\n宽度优先(Breadth First Search, BFS)的意思就是，优先遍历当前节点的所有子节点，不管子节点还有没有孙子节点。再一层一层向下遍历。\n\n通常需要借助`队列`来完成遍历，思路是：记录当前层的数量，开始遍历，将叶子节点放入队列，当遍历的数量等于当前层数量时，说明当前层已经遍历完了；检查队列是否为空，不为空说明还有下层，继续重复刚才的操作；知道全部遍历完成。\n\n```\npublic int maxDepthBfs(TreeNode root) {\n    int maxDepth = 0;\n    if (root == null) {\n        return maxDepth;\n    }\n    // 建立队列辅助计算，并添加根元素\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    // 队列不空就开始遍历\n    while (!queue.isEmpty()) {\n        // 记录当前层一共有多少个元素\n        int currentLevelSize = queue.size();\n        // 记录已经查看了多少个元素\n        int visitedSize = 0;\n        // 开始遍历当前层\n        while (visitedSize < currentLevelSize) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                if (node.left != null) {\n                    // 有左叶子节点，则加入队列\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    // 有右叶子节点，则加入队列\n                    queue.offer(node.right);\n                }\n            }\n            // 处理当前node的值，本例中无需处理\n            // 记录我们看过一个元素了，当当前层所有元素都看过之后，会退出当前while循环\n            visitedSize++;\n        }\n        // 遍历完一层的时候，最大深度+1，如果下层还有元素，则会继续遍历\n        maxDepth++;\n    }\n    // 所有节点遍历完成，返回结果\n    return maxDepth;\n}\n```\n","tags":["algorithm","leetcode","binary tree"],"categories":["Algorithm","Data Structure"]},{"title":"二分查找法从入门到精通","url":"/2020/Learning-Binary-Search/","content":"\n# 二分法的本质\n\n\n二分法通常用于在有序的集合中查找目标。通过O(1)的操作，将规模为`n`的问题分解为`n/2`，最终时间复杂度是`log(n)`。通常要求做到`log(n)`的时间复杂度，基本上都是二分法。\n\n\n# 二分法的痛点\n\n\n* 死循环\n  * 二分法通过`循环条件`+`指针变化`来推进，如果这两个组合不正确，就会导致死循环。\n* 是否可以使用递归(Recursion)\n  * 使用递归时，代码会更加清晰，写法更简单。不能用递归时，写法会复杂很多。有时候需要注意问题规模，使用递归是否可能导致溢出。\n\n\n# 二分法的基本写法\n\n\n```\nprivate int binarySearch(int[] nums, int target) {\n\n    // 对数据合法性进行判断\n    int badResult = -1;     // 表示没有target或nums不合法的数字，例如-1\n    if (nums不合法) {\n        return badResult;\n    }\n\n    // 设定左右指针\n    int left = 0;\n    int right = nums.length - 1;\n\n    // 开始循环\n    while (循环条件) {\n        \n        // 设定mid，这里的小技巧是使用右减左除以2再加上左，避免溢出，更好的写法是相加后无符号右移一位\n        int mid = (right + left) >>> 1;\n        \n        // 判断mid是否是所求目标，是的话返回\n        if (nums[mid] == target) {\n            return mid;\n        }\n\n        // 不是的话，判断移动左还是右指针，将问题规模减小一半\n        if (target在左侧) {\n            移动右指针\n        } else {\n            移动左指针\n        }\n    \n    }\n\n    // 视上述循环条件和移动指针的方式，执行额外的最终判断\n    最终判断\n    // 如果最终没有满足条件的结果，返回失败\n    return badResult;\n}\n```\n\n总结一下就是通过循环，不停的移动左右指针将问题规模减半，直到解决问题。\n\n这里的难点是`循环条件`和`移动左右指针的方法`，这两者使用不同的组合会有不同的效果，使用错了会导致死循环。下面我介绍一些常见的循环条件和移动左右指针的方法的组合。\n\n\n# 二分法常见模板\n\n\n基本上所有的二分查找算法都可以用下面3种模板之一来解决。\n\n## 模板1\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length - 1\n循环条件 | left <= right\n左指针移动 | left = mid + 1\n右指针移动 | right = mid - 1\n最终判断 | 无\n\n这个模板在退出循环时，left与right会交错而过(即left - 1 == right)，此时所有可能项目都查找过了，所以不需要额外的操作。\n\n\n## 模板2\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length\n循环条件 | left < right\n左指针移动 | left = mid + 1\n右指针移动 | right = mid\n最终判断 | left是否是target？\n\n模板2的right初始值需要注意一下，是length，这是为了配合left < right这个循环条件。\n\n这个模板在退出循环的时候，一定有left == right，此时因为不满足循环条件，所以这个值还没有判断过，于是在退出循环之后，还需要判断一次left是否是target（判断right也行，因为退出循环时left必然等于right）。\n\n\n## 模板3\n\n项目 | 代码\n--- | ---\n左指针 | left = 0\n右指针 | right = length - 1\n循环条件 | left + 1 < right\n左指针移动 | left = mid\n右指针移动 | right = mid\n最终判断 | left是否是target？right是否是target？\n\n模板3在退出循环的时候，left + 1 == right，也就是查找到了最后2个项目，这两个项目没有在循环中判断过，所以最终判断时需要分别看一下left和right是否是target\n\n\n# 模板的选择\n\n上面介绍了3种模板，他们的核心区别是\n\n<div style=\"width: 80px\">项目</div> | <div style=\"width: 33%\">模板1</div> | <div style=\"width: 33%\">模板2</div> | <div style=\"width: 33%\">模板3</div>\n--- | --- | --- | ---\n左指针 | left = 0 | left = 0 | left = 0\n右指针 | right = length - 1 | right = length | right = length - 1\n循环条件 | left <= right | left < right | left + 1 < right\n左指针移动 | left = mid + 1 | left = mid + 1 | left = mid\n右指针移动 | right = mid - 1 | right = mid | right = mid\n最终判断 | 无 | left是否在界限内，是不是target？ | left是否是target？right是不是target？\n核心区别 | 便于解决只需要通过元素本身就能判断是否为目标的问题 | 便于解决需要元素本身及邻居来判断是否为目标的问题 | 模板1、2的加强版，万能模板\n\n\n## 模板1 案例\n\n只要通过元素本身即可判断是否为目标的问题，用模板1会很方便。\n\n* [LeetCode 704. Binary Search](https://leetcode.com/problems/binary-search/)\n    > 经典二分查找法\n\n\n## 模板2 案例\n\n不仅要靠元素本身，还需要邻居才能判断是否为目标，用模板2更方便。\n\n* [LeetCode 278. First Bad Version](https://leetcode.com/problems/first-bad-version/) \n    > 处理`AA...AABB...BB`类型的问题，找出最后一个A或者第一个B。\n* [LeetCode 34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n    > 处理`AABBCCDD`类型的问题，找出B的开始和结束。\n* [LeetCode 162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\n    > 处理山峰的问题，非常典型。需要通过元素和邻居来判断指针如何移动。\n\n\n## 模板3 案例\n\n模板3是模板1、2的加强版，是一个万能二分法模板，基本上所有的二分法问题都能解决。\n有时候我们用模板2去做一些`AABB`类型的题目时，会碰到死循环，原因是左右中位数选择的问题，这个时候需要将mid换成右中位数( mid = right + left + 1 >>> 1; )，不熟练的话，你都不知道自己为什么死循环了。\n但我们用模板3，则简单无脑，所以你可以所有二分法都用模板3，反正肯定不会出错就是了。\n\n* [LintCode 183. Wood Cut](https://www.lintcode.com/problem/wood-cut/description)\n    > 这个例子如果用模板2，需要搞清楚用左右中位数的哪个，否则容易死循环，用模板3则轻松愉快。\n\n\n# 总结\n\n模板1到模板3是一个进化的关系，目的就是为了更方便的解决问题，不让自己陷入死循环。通常能用模板1解决的问题，都能用模板2解决；能用模板2解决的问题，都能用模板3解决。而且模板3是最不容易出错的写法。\n所以你可以只记住模板3的写法，它基本上能解决所有二分法问题。\n\n","tags":["binary search","algorithm","leetcode"],"categories":["Algorithm"]}]